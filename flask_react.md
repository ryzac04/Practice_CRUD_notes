# Flask/React App Notes
## Initial Setup
### Client Side 
From CLI, create app root directory and cd into it. Create the `server` and `client` directories. 
1. **Initialize React App**  
Different options exist for initializing the client side: 
   - Using npx create-react-app:
     - npx create-react-app app-name
   - Using vite
     - npm create vite@latest project-name -- --template react
   OR
     - npm create vite@latest . -- --template react (to place into folder that already exists - cd into folder and use . )
     - npm create vite@latest
     - Project name: project-name-here (usually `frontend` or `client`)
     - Select options wanted/needed for particular project
     - cd `client`
     - npm i 
2. **Dependencies**  
Download any needed dependencies. Some commonly used dependencies and where they should go in `package.json`:  
   - "dependencies" (npm i)
     - axios - handles HTTP requests
     - react-router-dom - enables routing in React
     - react-icons - provides a collection of popular icons
     - notistack - manages snackbars (notifications)
     - @chakra-ui/react - component library for accessible and customizable UI
     - @chakra-ui/icons - Chakra's icon package
     - @emotion/react & @emotion/styled - required by Chakra UI for styling
     - @tailwindcss/vite - Tailwind integreation for Vite
     - react-bootstrap - Bootstrap components for React
     - bootstrap - Bootstrap CSS framework 
   - "devDependencies" (npm i -D)
     - tailwindcss - utility-first CSS framework
     - postcss - CSS processor for Tailwind
     - autoprefixer - automatically adds vendor prefixes for CSS compatibility 
3. **TailwindCSS** 
   - `npm install -D tailwindcss postcss autoprefixer`: install Tailwind and required dependencies in "devDependencies" 
   - `npx tailwindcss init -p`: initialize Tailwind config files; creates tailwind.config.js and postcss.config.js

### Server Side
1. **Server Side Structure**  
Set up the project structure. An example might look like:
```
backend/
├── app/
│   ├── exceptions/
│   │   ├── __init__.py
│   │   |── api_exceptions.py
│   │   └── handlers.py 
│   ├── models/
│   │   ├── __init__.py
│   │   └── user.py
│   ├── routes/
│   │   ├── __init__.py
│   │   └── auth_routes.py
│   ├── services/
│   │   └── auth_service.py
│   ├── schemas/
│   │   └── user_schema.py
│   └── utils/
│       └── jwt_helper.py
│   ├── __init__.py
│   ├── config.py
│   ├── extensions.py
├── migrations/
│   └── (Auto-generated by Flask-Migrate)
├── .env
├── .env.example
├── .flaskenv
├── requirements.txt
├── run.py
└── README.md
```
To start, `touch` run.py, .env, .env.example. Also, `mkdir` app and `touch` `__init__.py`, config.py as well as `mkdir` models, routes, services, schemas, utils. Add other files/directories later as needed. 
**Notes on `__init__.py` Files:**
- `__init__.py`: turns a folder into a Python package. Allows for the use of relative imports (e.g., `from .user import User` as opposed to `from app.models import User`)
- `__init__.py` inside `app/`: where the Flask app is created using the factory pattern. 
- `__init__.py` inside `models/`: purpose is to import and register all models so they are recognized when initializing the database. Also to make sure they are discoverable when running migrations with Flask-Migrate. 
- Key Take-aways:
  - Package recognition: Python sees the folder as a package
  - Clean, relative imports: Allows things like `from .user import User`
  - Easier refactoring & IDE support: Autocomplete, jump-to-definition, etc.
  - Alembic migration detection: Ensures the models are loaded
  - Cleaner app structure: Organizes related code together into modules 
1. **venv**
   - Set up venv
     - python3 -m venv venv
     - to start: source venv/bin/activate
     - to end: deactivate 
2. **Dependencies**
   - Install any dependencies - the following are some common ones: 
     - pip install
       - flask - core web framework
       - flask-cors - enable cross-origin resource sharing (React <-> Flask communication)
       - flask-sqlalchemy - ORM for managing the PostgreSQL database in a Pythonic way
       - flask-migrate - handles SQLAlchemy database migrations using Alembic (official migration tool for SQLAlchemy)
       - flask-bcrypt - hash passwords securely 
       - flask-login - manage user sessions (login/logout)
       - python-dotenv - load env variables from a .env file 
       - psycopg2-binary - PostgreSQL driver (only if using PostgreSQL); allows Python to connect to PostgreSQL 
       - gunicorn - WSGI server for deploying the app (used in production, not dev)
       - flask-WTF
       - flask-marshmallow - Flask library for:
         - Serializing complex data types (like SQLAlchemy models) into JSON
         - Deserializing JSON back into Python objects
         - Validating input data (e.g., checking if a username is present and is a string)
       - flask-jwt-extended - Python library that simplifies implementation of JWT authentication in Flask applications. 
     - Note on python vs python3 and pip vs pip3
       - Once inside the venv, can just use `python` and `pip`. Inside Python 3 venvs, `python` points to the specific Python interpreter the venv was created with, and `pip` is tied to that venv's Python 3. 
       - Outside of the venv, use python3 and pip3 because this differentiates between Python 3 and Python 2 (which uses just `python` and `pip`).
   - Freeze dependencies into .txt file:
     - pip freeze > requirements.txt 
3. **.gitignore** 
   - Create .gitignore 
     - venv/
     - `__pycache__/`
     - instance/ 
     - .env (create .env.example file for others to follow if posting to github or collaborating with others but wanting to keep own secrets in .env private)
### Setting Up PostgreSQL for Flask
1. Install PosgreSQL (if not already installed)
```bash
# Install globally
sudo apt update
sudo apt install postgresql postgresql-contrib

# Start PostgreSQL service
sudo service postgresql start
```
2. Create a PostgreSQL user and database
```bash
# Enter the PostreSQL shell:
sudo -u postgres psql

# Inside the shell:
# Create a database user
CREATE USER flaskuser WITH PASSWORD 'yourpassword';

# Optional: Make the password never expire
ALTER ROLE flaskuser VALID UNTIL 'infinity';

# Create the database
CREATE DATABASE flask_db;

# Give your user full access to the new DB
GRANT ALL PRIVILEGES ON DATABASE flask_db TO flaskuser;

# Exit
\q
```
### Server Side Setup Continued
1. **`.env`**
```Python
# Flask environment settings
FLASK_APP=run.py # Tells Flask which file is the app entrypoint. 
FLASK_ENV=development # development enables debug mode and auto reload (use production in deployed apps).
FLASK_SECRET_KEY=secret_key_here # Used by Flask for sessions, signing cookies, CSRF protection, etc. Keep this secret! 

# Database URL 
DATABASE_URL=postgresql://username:password@localhost:5432/your_database_name # Connection string to the database.

# JWT Secret
JWT_SECRET_KEY=your_jwt_secret_key_here # Secret for JWT signing (if applicable)

# Other environment variables (e.g., email server, API keys) can go here 
```
**Notes on .env**
- When switching to production, change 'development' to production. Make sure to switch debug=False in app.run(). Also, use production-ready server (like Gunicorn) instead of flask run. 
- Generating Secret Keys (Secret Flask Key or JWT):
```bash shell

python -c "import secrets; print(secrets.token_hex(32))" 
# python: run Python interpreter
# -c: run the code passed as a string (instead of a .py file)
# import secrets: loads Python's built-in cryptographic secrets module
# secrets.token_hex(32): generates a random 64-character hex string (32 bytes = 256 bits = very secure)
# Example output: 
af6b71cc583293f3b7c37a5a14649c198a19ea7c4d873e8a89f7a7d1079dd72b
# Paste this into the .env file. 

# Option to automatically save to .env file 
echo "SECRET_KEY=$(python -c 'import secrets; print(secrets.token_hex(32))')" >> .env
# This will append a new line every time it is run - clean up duplicates as needed. 

# Using token_urlsafe(n):
echo "JWT_KEY=$(python -c 'import secrets; print(secrets.token_urlsafe(32))')" >> .env
# Returns a URL-safe string (uses - and _, never / or +)
# Best for JWTs, API keys in URLs, or anything embedded in a URL. 
```
2. **`app/config.py`**
```Python
import os
from dotenv import load_dotenv

# Load environment variables from .env file automatically
load_dotenv()

class Config:
    #Set environment mode, defaulting to 'production' if not specified
    FLASK_ENV = os.getenv("FLASK_ENV", "production")

    # Flask secret key - for securely signing cookies, sessions, CSRF, etc. Defaults to 'fallback-secret-key' if not specified. Not safe - do not do this in production! 
    SECRET_KEY = os.getenv("FLASK_SECRET_KEY", "fallback-flask-key")

    # SQLAlchemy database URI
    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL")

    # Turn off event system to save resources 
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY", "fallback-jwt-key")

    # Enables token revocation in Flask-JWT-Extended.
    JWT_BLACKLIST_ENABLED = True

    # Tells Flask-JWT-Extended to check access tokens against the blacklist (not refresh tokens).
    JWT_BLACKLIST_TOKEN_CHECKS = ["access"]
```
**Notes on JWT Blacklisting**: 
This is storing a list of revoked tokens (blacklist) and rejecting them if someone tries to reuse them. Can do this with Flask-JWT-Extended. This is a good safety measure to force-logout tokens early in the event they are compromised. This means there will need to be backend involvement isntead of just deleting the token from local storage or cookies on the frontend to log out users. 

**`app/utils`**
```Python
# /token_blacklist.py
token_blacklist = set()

def is_token_revoked(jwt_header, jwt_payload):
    # jti is JWT ID - this is automatically included in every JWT created by Flask-JWT-Extended. Can use this to track and revoke individual tokens. 
    jti = jwt_payload["jti"]
    return jti in token_blacklist

# /__init__.py
from .token_blacklist import token_blacklist
```

3. **`app/extensions.py`** 
```Python
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_jwt_extended import JWTManager
from flask_bcrypt import Bcrypt
from flask_cors import CORS

db = SQLAlchemy()
migrate = Migrate()
jwt = JWTManager()
bcrypt = Bcrypt() 
cors = CORS() 
```
4. **`app/models.py`**
```Python
from ..extensions import db
from datetime import datetime, timezone

class User(db.Model):
    __tablename__= 'users' # Specify the database table name explicitly. 

    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password = db.Column(db.String(128), nullable=False)
    created_at = db.Column(
        db.DateTime(timezone=True), # Timestamp column with timezone support
        default=lambda: datetime.now(timezone.utc)) # Default value is current UTC (Coordinated Universal Time) datetime (timezone-aware)

    def __repr__(self):
        # Defines string representation of User instances. Useful for debugging and logging. 
        return f"<User {self.username}>"

# app/models/__init__.py
from .user import User 
```
5. **`app/schemas.py`**
```Python
from marshmallow import Schema, fields, ValidationError, validates_schema, validate, EXCLUDE
import re

# Custom validator for password complexity.
def validate_password_complexity(password):
    pattern = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[\W_]).{8,}$'
    if not re.match(pattern, password):
        raise ValidationError(
            "Password must be at least 8 characters long and include at least one lowercase character, one uppercase character, one number, and one special character."
        )

# Full User schema (used for general user serialization and creation).
class UserSchema(Schema):
    # Meta class inside a Marshmallow schema is an optional configuration block.
    class Meta:
        unknown = EXCLUDE # Ignore unknown fields during deserialization
        # ordered = True # Keep field order in the output JSON

    id = fields.Int(dump_only=True) # Only included when serializing to JSON. Sent in responses, not needed in requests. 
    username = fields.Str(required=False, validate=validate.Length(min=3, max=80)) # Required string field, must be 3 - 80 characters.
    email = fields.Email(required=False, validate=validate.Length(max=120)) # Required and must be a valid email format. 
    password = fields.Str(
        load_only=True, # Allowed in requests, not returned in responses. 
        required=True, 
        validate=[validate.Length(min=6), validate_password_complexity]
        ) 
    created_at = fields.DateTime(dump_only=True) # Read-only timestamp, included when serializing to JSON. Sent in responses, not needed in requests. 

# Schema for login - username or email and password only.
class UserLoginSchema(Schema):
    class Meta:
        unknown = EXCLUDE
    
    username = fields.Str(required=False, validate=validate.Length(min=3, max=80))
    email = fields.Email(required=False, validate=validate.Length(max=120))
    password = fields.Str(
        load_only=True,
        required=True,
        validate=[validate.Length(min=8), validate_password_complexity]
    )

    # Marshmallow decorator - runs after all individual field validations. Used to validate relationships between fields and/or enforce rules that span multiple fields. 
    @validates_schema
    def require_email_or_username(self, data, **kwargs): # **kwargs is commonly used to pass a variable number of named arguments into a function (that the function may not explicitly define) so the function doesn't break if Marshmallow includes any extra arguments. 
        if not data.get("username") and not data.get("email"):
            raise ValidationError("Either 'email' or 'username' must be provided.")
```
6. **`app/exceptions`**  
**Note on Exceptions** 
There are different ways to deal with exceptions in Flask. As a general rule of thumb, a combination of global handlers, local handlers, and custom exception classes can be used in combination with each other depending on what is needed to do with the error and/or how much control is needed. These strategies are not mutually exclusive - they can (and often should) be used together to create clear, maintainable, and robust error-handling logic. 
- Global Handlers: registered using `@app.errorhandler(...)` to catch specific exceptions across the entire application and return a consistent error response. 
  - When to use: 
    - Need for a centralized place to format and return error responses (e.g., JSON error messages)
    - Need for reducing repetitive error-handling code in routes
    - need for intercepting custom exceptions and responding gracefully
```python
@app.errorhandler(InvalidUsage)
def handle_invalid_usage(error):
  response = jsonify(error.to_dict())
  return response, error.status_code 
```
- Local Handlers: block-level exception handling within a specific function or route, using Python's native `try/except` syntax. 
  - When to use:
    - Need for fine-grained control at a specific point in the code
    - Need for handling recoverable errors, rollback DB operations, or run alternate logic
    - Need for logging or transforming an error before re-raising
```python
try:
  db.session.add(new_user)
  db.session.commit()
except IntegrityError:
  db.session.rollback()
  raise InvalidUsage("Email already exists.", status_code=409)
```
- Custom Handlers: user-defined subclasses of `Exception` that encapsulates reusable error information, such as status codes and custom messages. 
  - When to use: 
    - Need for domain-specific error types (e.g., `InvalidUsage`, `AuthenticationError`)
    - Need to bundle metadata with an error (e.g., `status_code`, `payload`, `field`)
    - Need to raise predictable exceptions for global handlers to catch 
```python
class InvalidUsage(Exception):
    def __init__(self, message, status_code=400, payload=None):
        super().__init__(message)
        self.message = message
        self.status_code = status_code
        self.payload = payload or {}

    def to_dict(self):
        response = dict(self.payload)
        response['message'] = self.message
        return response
```
Putting Together (for fun!):
```python
try:
    if user_exists:
        raise InvalidUsage("Email already exists", status_code=409)
    db.session.add(user)
    db.session.commit()
except InvalidUsage as e:
    raise  # Bubbles up to global handler
except Exception as e:
    db.session.rollback()
    logger.exception("Unhandled error during user creation.")
    raise InvalidUsage("Unexpected error", status_code=500)
```
| Type              | Scope            | Use For                                                 | Example Use Case                                |
| ----------------- | ---------------- | ------------------------------------------------------- | ----------------------------------------------- |
| Global Handlers   | Application-wide | Formatting JSON errors, catching common exception types | All `InvalidUsage` errors return JSON           |
| Local Handlers    | Per-function     | Business logic, recovery, DB rollbacks                  | Retry DB insert, skip loop, log and continue    |
| Custom Exceptions | Reusable types   | Defining domain-specific error types                    | `InvalidUsage`, `AuthError`, `PermissionDenied` |

Can use handlers together as needed for different situations. 

Setup `app/exceptions/` folder with `__init__.py`, `api_exceptions.py`, and `handlers.py`. 
```python
# api_exceptions.py
class InvalidUsage(Exception):
    """Custom exception for API errors with custom messages and status codes. """

    def __init__(self, message, status_code=400, payload=None):
        super().__init__(message)
        self.message = message
        self.status_code = status_code
        self.payload = payload or {}

    def to_dict(self):
        response = dict(self.payload)
        response['message'] = self.message
        return response 

# handlers.py
from flask import jsonify
from marshmallow import ValidationError
from werkzeug.exceptions import HTTPException
from .api_exceptions import InvalidUsage

def register_error_handlers(app):

    @app.errorhandler(InvalidUsage)
    def handle_invalid_usage(error):
        response = jsonify({
            "error": error.to_dict(),
            "code": error.status_code
        })
        return response, error.status_code 

    @app.errorhandler(ValidationError)
    def handle_validation_error(err):
        return jsonify({
            "error": {
                "messages": err.messages,
                "code": 400
            }
        }), 400 
    
    @app.errorhandler(HTTPException)
    def handle_http_exception(err):
        return jsonify({
            "error": {
                "message": err.description,
                "code": err.code
            }
        }), err.code 
    
    @app.errorhandler(Exception)
    def handle_unexpected_error(err):
        app.logger.error(f"Unexpected error: {err}")
        return jsonify({
            "error": {
                "message": "Internal server error",
                "code": 500
            }
        }), 500 

# __init__.py
from .api_exceptions import InvalidUsage
from .handlers import register_error_handlers
```
**Note on Decorators** 
Decorators (e.g., @app.errorhandler()) are functions that wrap another function to add extra behavior without changing the original function's code. It takes the wrapped function as an argument and returns a new (wrapped) function. 
```Python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello, World!'
```
- In this common example, the decorator takes the `hello()` function as an argument and registers it with the Flask application's routing system. 
- It tells Flask: "When a request arrives forthe URL '/', call this `hello()` function. 
- When the browser accesses the specified route (e.g., `http://localhost:5000/`), Flask retrieves the function associated with that route and executes it. 
- The closer decorator to the defined function will execute first. 

7. **`app/__init__.py`**  
Factory pattern to initialize and return the Flask app. 
```Python
from flask import Flask
from .config import Config
from .extensions import db, migrate, jwt, cors, bcrypt
from .utils.token_blacklist import is_token_revoked
from app.exceptions import register_error_handlers
from app.routes import auth_bp, user_bp # import blueprint objects 

def create_app():
    app = Flask(__name__)

    # Load config from config.py.
    app.config.from_object(Config)

    # Initialize Flask extensions with app. 
    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    # Registers a callback that determines whether a token is blacklisted. 
    jwt.token_in_blocklist_loader(is_token_revoked)
    bcrypt.init_app(app)
    cors(app)


    # Register the app's error handlers 
    register_error_handlers(app) 

    # Set up the above initializations first before continuing past this point. After that, create and then initialize as you go. 
    # Registers the app's routes/blueprints. 
    app.register_blueprint(auth_bp)
    app.register_blueprint(user_bp)

    return app 

```
**Notes on importing and Python interpretor**
- Import needed dependencies at the top 
  - Note: if Import "flask" could not be resolved, make sure the IDE is using the correct Python interpretor. Use the venv's Python instead of the global system's Python: 
    - ctrl+shift+p
    - run "Python:Select Interpretor"
    - choose/point to venv/bin/python 

8. **`run.py`**  
Entrypoint of the app. `run.py` is the script that tells Flask to start the app.
```Python
from app import create_app

app = create_app()

if __name__ == "__main__":
    app.run(debug=True)
```
**Notes on `__name__`:**
- In Python, every module (file) has a special built-in variable called `__name__` that tells how a Python file is being run - either directly or imported as a module.  
- If a file is run directly, `__name__ == "__main__"`. This means the file will execute automatically (it is a script). 
- If it's imported as a module, `__name__ == "filename"`. This means the file will not run automatically (it is a module and must be invoked). 
- This allows us to:
  - Separate reusable modules from scripts 
  - Prevent code from executing during imports  

**Hypothetical Example:**
- If run.py is run directly using `python run.py`:
  - `__name__ == "__main__"`
  - So `app.run(debug=True)` executes
  - The Flask development server starts with debug mode ON  
- If run.py is imported as a module using `import run` (hypothetically):
  - `__name__ == "run"` (not `"__main__"`)
  - So `app.run(debug=True)` does NOT execute
  - The app object exists, but the server won't start automatically.

### Blueprints and Routes 
Setup `app/routes/` folder with `auth_routes.py`, `user_routes.py`, and `__init__.py`: 
1. **`auth_routes.py`**
For login, registration, logout.

```python
from flask import Blueprint, request, jsonify
from flask_jwt_extended import create_access_token, jwt_required, get_jwt
from datetime import timedelta

from ..models import User
from ..extensions import db, bcrypt
from ..schemas import UserSchema, UserLoginSchema
from ..utils import token_blacklist

from app.exceptions import InvalidUsage

# Create new blueprint called 'auth' and all routes here will be prefixed with '/api/auth'.
auth_bp = Blueprint('auth', __name__, url_prefix='/api/auth')

# Instantiate schemas.
user_schema = UserSchema()
login_schema = UserLoginSchema()

@auth_bp.route('/register', methods=['POST'])
def register(): 
    data = user_schema.load(request.json)
    
    if User.query.filter_by(username=data["username"]).first():
        raise InvalidUsage(
            "Username already exists.",
            status_code=409,
            payload={"field": "username"}
        )
    
    if User.query.filter_by(email=data["email"]).first():
        raise InvalidUsage(
            "Email already exists.",
            status_code=409,
            payload={"field": "email"}
        )
    
    hashed_password = bcrypt.generate_password_hash(data['password']).decode('utf-8')

    new_user = User(
        username=data['username'],
        email=data['email'],
        password=hashed_password
    )

    try:
        # Attempt to add the new_user object to the current database session
        db.session.add(new_user)

        # Try to commit (save) the session changes to the database
        db.session.commit()

    except Exception as err:
        # If *any* exception occurs during the add or commit operations...

        # Roll back the current database session to prevent partial writes or corruption
        db.session.rollback()

        # Log the error with details using Flask's built-in logger
        # This message will appear in the terminal (or log file if configured)
        current_app.logger.error(f"Database error during registration: {err}")

        # Raise a custom application error using your defined InvalidUsage exception
        # This sends a safe, generic error response to the client with a 500 status code
        raise InvalidUsage("Database error during registration.", 500)

    # Dumps the user object as JSON, omitting the password thanks to the schema. 
    return jsonify(user_schema.dump(new_user)), 201

@auth_bp.route('/login', methods=['POST'])
def login():
    # Validate login credentials. 
    data = login_schema.load(request.json)

    # Look up the user by username or email. 
    user = None
    if data.get('username'):
        user = User.query.filter_by(username=data['username']).first()
    elif data.get('email'):
        user = User.query.filter_by(email=data['email']).first() 

    # Check that user exists and password matches. 
    if not user or not bcrypt.check_password_hash(user.password, data['password']):
        raise InvalidUsage("Invalid credentials.", status_code=401)
    
    # Create JWT and send back. 
    access_token = create_access_token(identity=user.id, expires_delta=timedelta(hours=1))
    return jsonify(access_token=access_token), 200 

@auth_bp.route('/logout', methods=["POST"])
# Protects routes by requiring a valid JWT. It sends the request (typically as an Authorization: Bearer <token> header) and ensures it is valid, not expired, and not revoked (blacklist config). Sends 401 Unauthorized if not valid. 
@jwt_required()
def logout():
    jti = get_jwt()["jti"]
    token_blacklist.add(jti)
    return jsonify({"msg": "Successfully logged out"}), 200 
```
2. **`user_routes.py`**
```python
from flask import Blueprint, request, jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.models import User, db
from app.schemas.user_schema import user_schema, users_schema
from app.exceptions import InvalidUsage

user_bp = Blueprint("user_bp", __name__, url_prefix="/api/users")


# Get a specific user's profile
@user_bp.route("/<int:id>", methods=["GET"])
@jwt_required()
def get_user(id):
    current_user_id = get_jwt_identity()
    if current_user_id != id:
        raise InvalidUsage("Unauthorized access", 403)

    user = User.query.get(id)
    if not user:
        raise InvalidUsage("User not found", 404)

    return jsonify(user_schema.dump(user)), 200


# Get all users (could be admin-only if extended)
@user_bp.route("/", methods=["GET"])
@jwt_required()
def get_users():
    try:
        users = User.query.all()
        return jsonify(users_schema.dump(users)), 200
    except Exception as err:
        current_app.logger.error(f"Error retrieving users: {err}")
        raise InvalidUsage("Could not retrieve users", 500)


# Update a specific user's profile
@user_bp.route("/<int:id>", methods=["PATCH"])
@jwt_required()
def update_user(id):
    current_user_id = get_jwt_identity()
    if current_user_id != id:
        raise InvalidUsage("Unauthorized update attempt", 403)

    user = User.query.get(id)
    if not user:
        raise InvalidUsage("User not found", 404)

    try:
        data = user_schema.load(request.json, partial=True)

        for field, value in data.items():
            setattr(user, field, value)

        db.session.commit()
        return jsonify(user_schema.dump(user)), 200

    except Exception as err:
        db.session.rollback()
        current_app.logger.error(f"Error updating user {id}: {err}")
        raise InvalidUsage("Error updating user", 500)


# Delete a specific user's account
@user_bp.route("/<int:id>", methods=["DELETE"])
@jwt_required()
def delete_user(id):
    current_user_id = get_jwt_identity()
    if current_user_id != id:
        raise InvalidUsage("Unauthorized delete attempt", 403)

    user = User.query.get(id)
    if not user:
        raise InvalidUsage("User not found", 404)

    try:
        db.session.delete(user)
        db.session.commit()
        return jsonify(message="User deleted"), 200

    except Exception as err:
        db.session.rollback()
        current_app.logger.error(f"Error deleting user {id}: {err}")
        raise InvalidUsage("Error deleting user", 500)
```
3. **`__init__.py`**
Implement `register_routes(app)` function that imports and registers these blueprints. 
```python
from .auth_routes import auth_bp
from .user_routes import user_bp

__all__ = ["auth_bp", "user_bp"]
```
### Refactor Routes - to be completed later 

Misc Notes to be integrated later: 
## Poetry
### No Created Directory 
* poetry new flask-app-name
  * Creates a default project structure 
* cd flask-app-name
* Add dependencies
  * poetry add flask flask-cors python-dotenv, etc 
* Structure the project (can use example above) 
* Run through basic setup to connect to localhost w/ greeting message
* Activate poetry shell
  * poetry shell 
* Run flask app
  * python run.py 
  * If using flask CLI with an app factory: 
    * export FLASK_APP=run.py
    * flask run 
* Using a .env file:
  * poetry add python-dotenv
  * Add this to `__init__.py` before creating the app:
    * from dotenv import load_dotenv
    * load_dotenv() 
### Directory Already Created
* cd my-flask-project
* poetry init
* Go through questions:
  * Can hit enter to accept defaults
  * If defining dependencies interactively, can immediately add flask and other dependencies 
* Will now have pyproject.toml
* Run:
  * poetry install: installs the dependencies
  * poetry shell: activates the venv 

## Helpful CLI Commands
* pip show package_name 
  * Result: shows several pieces of information regarding the package 
* pip freeze | grep package_name 
  * pip freeze: outputs a list of all Python packages installed in the current environment, along with their exact versions, in the format:
    * package_name==version 
  * | (pipe): takes the output command on the left (pip freeze) and passes it as input to the command on the right (grep).
  * grep package_name: searches the input for the string "package_name" and outputs only the matching lines. 
  * Result: package_name==version
* pip list | grep -i package_name
  * Result: shows all packages with "package_name" somewhere in their name, regardless of capitalization 
  * pip list: shows all installed Python packages with their versions in a table
  * | grep -i package_name: filters this list to only show lines containing "package_name" (case-insensitive because of -i). 
********************************************************************************************************************

app.py:
from flask import Flask, render_template, redirect, session, flash, whatever else you may need
from flask_debugtoolbar import DebugToolbarExtension
from models import connect_db, db, ModelNames
from forms import FormNames

app = Flask(__name__)
app.config["SQLALCHEMY_DATABASE_URI"] = "postgresql:///db_name"
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
app.config["SQLALCHEMY_ECHO"] = True
app.config["SECRET_KEY"] = "abc123"
app.config['DEBUG_TB_INTERCEPT_REDIRECTS'] = False


connect_db(app)

toolbar = DebugToolbarExtension(app)

*********************************************************************************************************************

models.py:
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import Text
from flask_bcrypt import Bcrypt

db = SQLAlchemy()

bcrypt = Bcrypt()

def connect_db(app):
    """Connect to database."""

    app.app_context().push()
    db.app = app
    db.init_app(app)

to make relations in the models: 
from ipython (venv):

db.create_all()
db.drop_all()

*********************************************************************************************************************

forms.py:
from flask_wtf import FlaskForm
from wtforms import StringField, FloatField, PasswordField, WhateverYouNeed
from wtforms.validators import InputRequired, Optional, Email, WhateverYouNeed

Example of WTForms in HTML:

{% extends 'base.html'  %}

{% block content %}

<h1 class="display-1">Login</h1>
<p class="lead">Login Below. Don't have an account? <a href="/register">Register here</a></p>

<form method="POST">

  {{ form.hidden_tag() }}

  {% for field in form
    if field.widget.input_type != 'hidden' %}
  <p>
    {{ field.label }}
    {{ field(class_="form-control") }}

    {% for error in field.errors %}
    <span class="form-text text-danger">{{ error }}</span>
    {% endfor %}
  </p>
  {% endfor %}

  <button class="btn btn-success" type="submit">Login</button>

</form>
{% endblock %}

pip install email_validator, then can import Email and use like the rest of the validators.
*********************************************************************************************************************

Venv:
• python3 -m venv venv
• source venv/bin/activate
• deactivate 

Requirements: 
• pip3 freeze > requirements.txt
• pip install -r requirements.txt
• pip install -r path/to/requirements.txt

Run Python File:
• from regular command line: python3 name.py

iPython:
• from regular command line: ipython
• %run name.py
• db.create_all() - create all tables 

Flask: 
• flask run --debug

PSQL
• from regular command line: createdb name
• from regular command line: dropdb name
• from regular command line: psql < seed_file_name.sql
• from regular command line: psql -f file_name.sql - executes the file - makes db if not made yet
• psql to enter psql
• \c db_name
• \i file_name.sql or path/to/file_name.sql - run a file and create tables to the db - must be connected first
• \dt - brings up list of all relations
• \dt name - brings up only the named table 
• \d+ name - see the schema
• \d - see all the data - not just data tables
• SELECT * FROM name - select all from table. 
• Thought-Process for M:M SQL querying:
1. What are we selecting?
2. Where from?
3. Join if needed - have to decide what kind of join - L, R, middle - based on data
4. What tables are we joining?
5. What specific data are we joining on in these tables?
6. Repeat join process as needed until all data from step 1 is accounted for
7. Pull specific data from query if needed - Where can be helpful here

Example:
This is from unit 41.2 node-pg relationships M:M video code
1. SELECT m.id, m.msg, t.tag
2. FROM messages AS m
3. & 4. LEFT JOIN messages_tags AS mt
5. ON m.id = mt.message_id
6. LEFT JOIN tags AS t
ON mt.tag_code = t.code
7. WHERE m.id = 1;

********************************************************************************************************************

pdb
• import pdb; pdb.set_trace()

*********************************************************************************************************************

Testing:
• python3 -m unittest test_file_name.py

*********************************************************************************************************************

Deploying w/ Render:
• Seeding new db w/ ElephantSQL:
  - $ pg_dump -O db_name | psql (url you copied here)
• Checking db:
  - $ psql (url you copied here)
• Render:
  - (venv) $ pip install gunicorn
  - (venv) pip freeze > requirements.txt 
  - Get to Render
  - Connect to your repository
  - Give it a name *(this must be globally unique)*
  - Make sure the start command is `gunicorn app:app`
  - Choose advanced, and enter environmental variables:
     - *DATABASE_URL*: URL from ElephantSQL (change `postgres:` → `postgresql:`)
     - *Change this in your app.py as well - otherwise Render will be looking for your local db.
     - *SECRET_KEY*: anything you want *(to be secure: long and random)*
     - *PYTHON_VERSION*: 3.X.X - whichever version you are using 
  - Choose “Create Web Service”

*********************************************************************************************************************